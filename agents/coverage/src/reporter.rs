use crate::analyzer::{CoverageData, UncoveredItem};
use anyhow::{Context, Result};
use std::process::Command;

pub fn print_console_report(coverage: &CoverageData, uncovered: &[UncoveredItem], threshold: f32) {
    println!("\nðŸ“Š Coverage Report");
    println!("==================");
    println!(
        "Overall: {:.1}% (threshold: {:.1}%)",
        coverage.overall_percentage, threshold
    );

    if coverage.overall_percentage >= threshold {
        println!("âœ… Meets threshold");
    } else {
        println!("âŒ Below threshold");
    }

    println!("\nðŸ“‹ Uncovered Items ({}):", uncovered.len());
    for item in uncovered {
        println!(
            "  {} {}:{} - {} ({:.1}% coverage)",
            severity_icon(item.severity()),
            item.file,
            item.line,
            item.function,
            item.coverage_percentage
        );
    }
}

pub fn generate_markdown_report(
    coverage: &CoverageData,
    uncovered: &[UncoveredItem],
    threshold: f32,
) -> String {
    let mut report = String::new();

    report.push_str("# Coverage Report\n\n");
    report.push_str(&format!(
        "**Overall Coverage:** {:.1}% (threshold: {:.1}%)\n\n",
        coverage.overall_percentage, threshold
    ));

    if uncovered.is_empty() {
        report.push_str("âœ… All code meets coverage threshold!\n");
        return report;
    }

    report.push_str(&format!("## Uncovered Items ({})\n\n", uncovered.len()));
    report.push_str("| File | Line | Function | Coverage | Severity |\n");
    report.push_str("|------|------|----------|----------|----------|\n");

    for item in uncovered {
        report.push_str(&format!(
            "| `{}` | {} | `{}` | {:.1}% | {} |\n",
            item.file,
            item.line,
            item.function,
            item.coverage_percentage,
            item.severity()
        ));
    }

    report
}

pub fn generate_json_report(
    coverage: &CoverageData,
    uncovered: &[UncoveredItem],
    threshold: f32,
) -> Result<String> {
    let report = serde_json::json!({
        "overall_percentage": coverage.overall_percentage,
        "threshold": threshold,
        "meets_threshold": coverage.overall_percentage >= threshold,
        "uncovered_count": uncovered.len(),
        "uncovered_items": uncovered,
    });

    serde_json::to_string_pretty(&report).context("Failed to serialize report")
}

pub fn generate_csv_report(
    coverage: &CoverageData,
    uncovered: &[UncoveredItem],
    threshold: f32,
) -> String {
    let mut csv = String::new();

    // Header
    csv.push_str(&format!(
        "# Overall Coverage: {:.1}% (threshold: {:.1}%)\n",
        coverage.overall_percentage, threshold
    ));
    csv.push_str(&format!(
        "# Meets Threshold: {}\n",
        coverage.overall_percentage >= threshold
    ));
    csv.push_str(&format!("# Uncovered Items: {}\n", uncovered.len()));
    csv.push_str("\n");

    // CSV header row
    csv.push_str("File,Line,Function,Coverage,Severity,Type\n");

    // Data rows
    for item in uncovered {
        csv.push_str(&format!(
            "\"{}\",{},\"{}\",{:.1}%,{},{:?}\n",
            item.file,
            item.line,
            item.function,
            item.coverage_percentage,
            item.severity(),
            item.item_type
        ));
    }

    csv
}

pub fn create_github_issues(uncovered: &[UncoveredItem]) -> Result<()> {
    for item in uncovered {
        let title = item.title();
        let body = format!(
            "**File:** `{}:{}`\n\n**Function:** `{}`\n\n**Coverage:** {:.1}%\n\n**Severity:** {}\n\n## Description\n\nThis function has insufficient test coverage. Please add tests to cover:\n\n- Normal/happy path\n- Edge cases\n- Error conditions\n- Boundary values\n\n---\n*Auto-generated by coverage*",
            item.file, item.line, item.function, item.coverage_percentage, item.severity()
        );

        let label = match item.severity() {
            "error" => "testing,priority-high",
            "warning" => "testing",
            _ => "testing,good-first-issue",
        };

        let output = Command::new("gh")
            .args([
                "issue", "create", "--title", &title, "--body", &body, "--label", label,
            ])
            .output()
            .context("Failed to execute gh command")?;

        if !output.status.success() {
            eprintln!(
                "Failed to create issue for {}: {}",
                item.function,
                String::from_utf8_lossy(&output.stderr)
            );
        } else {
            let issue_url = String::from_utf8_lossy(&output.stdout);
            println!("  âœ“ Created: {}", issue_url.trim());
        }
    }

    Ok(())
}

fn severity_icon(severity: &str) -> &str {
    match severity {
        "error" => "ðŸ”´",
        "warning" => "ðŸŸ¡",
        _ => "ðŸ”µ",
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::analyzer::{CoverageData, UncoveredItem, UncoveredType};

    #[test]
    fn test_markdown_report_generation() {
        let coverage = CoverageData {
            overall_percentage: 75.0,
            files: vec![],
        };

        let uncovered = vec![UncoveredItem {
            file: "src/lib.rs".to_string(),
            function: "uncovered_func".to_string(),
            line: 42,
            coverage_percentage: 30.0,
            item_type: UncoveredType::Function,
        }];

        let report = generate_markdown_report(&coverage, &uncovered, 80.0);

        assert!(report.contains("75.0%"));
        assert!(report.contains("uncovered_func"));
        assert!(report.contains("src/lib.rs"));
    }

    #[test]
    fn test_json_report_serialization() {
        let coverage = CoverageData {
            overall_percentage: 85.5,
            files: vec![],
        };

        let uncovered = vec![];
        let json = generate_json_report(&coverage, &uncovered, 80.0).unwrap();

        assert!(json.contains("85.5"));
        assert!(json.contains("\"meets_threshold\": true"));
    }
}
