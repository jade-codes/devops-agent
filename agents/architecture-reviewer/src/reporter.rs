use anyhow::{Context, Result};
use std::process::Command;

use crate::analyzer::{ArchitectureReport, Issue, Severity};

/// Output report and issues as JSON
pub fn output_json(report: &ArchitectureReport, issues: &[Issue]) -> Result<()> {
    #[derive(serde::Serialize)]
    struct Output<'a> {
        report: &'a ArchitectureReport,
        filtered_issues: &'a [Issue],
    }

    let output = Output {
        report,
        filtered_issues: issues,
    };

    let json = serde_json::to_string_pretty(&output)?;
    println!("{}", json);
    Ok(())
}

/// Output report as Markdown
pub fn output_markdown(report: &ArchitectureReport, issues: &[Issue]) -> Result<()> {
    println!("# Architecture Review Report\n");

    println!("## Overview\n");
    println!("- **Modules:** {}", report.module_count);
    println!("- **Total Lines:** {}", report.total_lines);
    println!("- **Patterns Detected:** {}", report.patterns.len());
    println!("- **Issues Found:** {}\n", issues.len());

    if !report.patterns.is_empty() {
        println!("## Design Patterns\n");
        for pattern in &report.patterns {
            println!(
                "- **{:?}** in {} (confidence: {:.0}%)",
                pattern.pattern_type,
                pattern.location,
                pattern.confidence * 100.0
            );
        }
        println!();
    }

    if !issues.is_empty() {
        println!("## Issues\n");
        for issue in issues {
            println!("### {} [{:?}]", issue.title, issue.severity);
            println!("\n**Description:** {}", issue.description);
            println!("\n**Category:** {}", issue.category);
            println!("\n**Locations:**");
            for loc in &issue.locations {
                println!("- {}", loc);
            }
            println!("\n**Suggestion:** {}\n", issue.suggestion);
        }
    }

    Ok(())
}

/// Output report to console
pub fn output_console(report: &ArchitectureReport, issues: &[Issue]) -> Result<()> {
    println!("\nðŸ“ˆ Architecture Metrics:");
    println!("   Modules: {}", report.module_count);
    println!("   Lines of code: {}", report.total_lines);
    println!(
        "   Avg lines per module: {}",
        report.total_lines / report.module_count.max(1)
    );

    if !report.patterns.is_empty() {
        println!("\nâœ¨ Design Patterns Detected:");
        for pattern in &report.patterns {
            println!(
                "   {:?} in {} ({:.0}% confidence)",
                pattern.pattern_type,
                pattern.location,
                pattern.confidence * 100.0
            );
        }
    }

    if !issues.is_empty() {
        println!("\nâš ï¸  Architectural Issues:\n");
        for issue in issues {
            let severity_icon = match issue.severity {
                Severity::High => "ðŸ”´",
                Severity::Medium => "ðŸŸ¡",
                Severity::Low => "ðŸŸ¢",
            };

            println!("{} {} [{}]", severity_icon, issue.title, issue.category);
            println!("   {}", issue.description);
            println!("   ðŸ’¡ {}", issue.suggestion);
            println!();
        }
    } else {
        println!("\nâœ… No architectural issues detected!");
    }

    Ok(())
}

/// Create GitHub issues for architectural findings
pub fn create_github_issues(issues: &[Issue], repo: &str) -> Result<()> {
    println!("\nðŸš€ Creating GitHub issues...");

    for issue in issues {
        let title = format!("[Architecture] {}", issue.title);

        let body = format!(
            "**Description:** {}\n\n**Category:** {}\n**Severity:** {:?}\n\n**Locations:**\n{}\n\n**Suggestion:**\n{}\n\n---\n*Generated by Architecture Reviewer Agent*",
            issue.description,
            issue.category,
            issue.severity,
            issue
                .locations
                .iter()
                .map(|l| format!("- {}", l))
                .collect::<Vec<_>>()
                .join("\n"),
            issue.suggestion
        );

        let label = match issue.severity {
            Severity::High => "priority: high",
            Severity::Medium => "priority: medium",
            Severity::Low => "priority: low",
        };

        let output = Command::new("gh")
            .args([
                "issue",
                "create",
                "--repo",
                repo,
                "--title",
                &title,
                "--body",
                &body,
                "--label",
                label,
                "--label",
                "architecture",
                "--label",
                &issue.category,
            ])
            .output()
            .context("Failed to create GitHub issue")?;

        if output.status.success() {
            let url = String::from_utf8_lossy(&output.stdout).trim().to_string();
            println!("   âœ“ Created: {}", url);
        } else {
            eprintln!("   âœ— Failed: {}", String::from_utf8_lossy(&output.stderr));
        }
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::analyzer::{Pattern, PatternType};

    #[test]
    fn test_output_console() {
        let report = ArchitectureReport {
            module_count: 10,
            total_lines: 1000,
            patterns: vec![],
            issues: vec![],
            dependencies: std::collections::HashMap::new(),
        };

        assert!(output_console(&report, &[]).is_ok());
    }

    #[test]
    fn test_output_console_with_patterns() {
        let report = ArchitectureReport {
            module_count: 5,
            total_lines: 500,
            patterns: vec![Pattern {
                pattern_type: PatternType::Singleton,
                location: "src/config.rs".to_string(),
                confidence: 0.9,
            }],
            issues: vec![],
            dependencies: std::collections::HashMap::new(),
        };

        assert!(output_console(&report, &[]).is_ok());
    }
}
