use anyhow::{Context, Result};
use regex::Regex;
use serde::{Deserialize, Serialize};
use std::fs;
use std::path::{Path, PathBuf};
use std::process::Command;
use walkdir::WalkDir;

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct TodoItem {
    pub file: String,
    pub line: usize,
    pub todo_type: TodoType,
    pub content: String,
    pub issue_reference: Option<String>,
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
pub enum TodoType {
    Todo,
    Fixme,
    Note,
    Hack,
    XXX,
}

impl TodoItem {
    pub fn title(&self) -> String {
        let prefix = match self.todo_type {
            TodoType::Todo => "TODO",
            TodoType::Fixme => "FIXME",
            TodoType::Note => "NOTE",
            TodoType::Hack => "HACK",
            TodoType::XXX => "XXX",
        };

        // Clean up content for title (first line, max 60 chars)
        let cleaned = self
            .content
            .lines()
            .next()
            .unwrap_or(&self.content)
            .trim()
            .chars()
            .take(60)
            .collect::<String>();

        format!("{}: {}", prefix, cleaned)
    }

    pub fn display(&self) -> String {
        format!(
            "{}:{} [{}] {}{}",
            self.file,
            self.line,
            self.todo_type.as_str(),
            self.content,
            if let Some(ref issue) = self.issue_reference {
                format!(" (ref: {})", issue)
            } else {
                String::new()
            }
        )
    }

    pub fn needs_issue(&self) -> bool {
        self.issue_reference.is_none() && matches!(self.todo_type, TodoType::Todo | TodoType::Fixme)
    }
}

impl TodoType {
    pub fn as_str(&self) -> &str {
        match self {
            TodoType::Todo => "TODO",
            TodoType::Fixme => "FIXME",
            TodoType::Note => "NOTE",
            TodoType::Hack => "HACK",
            TodoType::XXX => "XXX",
        }
    }
}

impl std::fmt::Display for TodoType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

pub fn scan_todos(
    repo_path: &Path,
    include_patterns: &[String],
    exclude_patterns: &[String],
) -> Result<Vec<TodoItem>> {
    let mut todos = Vec::new();

    // Regex to match TODO/FIXME/NOTE with optional issue reference
    // Matches: TODO, FIXME, NOTE, HACK, XXX
    // Optional: (#123), (issue #123), (gh-123), etc.
    let todo_regex =
        Regex::new(r"(?i)(TODO|FIXME|NOTE|HACK|XXX)(\s*\((?:issue\s*)?#?\d+\))?:?\s*(.*)")?;

    for entry in WalkDir::new(repo_path)
        .follow_links(false)
        .into_iter()
        .filter_entry(|e| !is_excluded(e.path(), exclude_patterns))
    {
        let entry = entry?;
        let path = entry.path();

        if !path.is_file() {
            continue;
        }

        if !matches_any_pattern(path, include_patterns) {
            continue;
        }

        let content = match fs::read_to_string(path) {
            Ok(c) => c,
            Err(_) => continue, // Skip binary files
        };

        let relative_path = path
            .strip_prefix(repo_path)
            .unwrap_or(path)
            .display()
            .to_string();

        for (line_num, line) in content.lines().enumerate() {
            if let Some(captures) = todo_regex.captures(line) {
                let todo_type = match captures.get(1).unwrap().as_str().to_uppercase().as_str() {
                    "TODO" => TodoType::Todo,
                    "FIXME" => TodoType::Fixme,
                    "NOTE" => TodoType::Note,
                    "HACK" => TodoType::Hack,
                    "XXX" => TodoType::XXX,
                    _ => continue,
                };

                let issue_ref = captures.get(2).map(|m| m.as_str().to_string());
                let content = captures.get(3).unwrap().as_str().trim().to_string();

                todos.push(TodoItem {
                    file: relative_path.clone(),
                    line: line_num + 1,
                    todo_type,
                    content,
                    issue_reference: issue_ref,
                });
            }
        }
    }

    Ok(todos)
}

pub fn create_github_issues(todos: &[TodoItem]) -> Result<()> {
    for todo in todos {
        if !todo.needs_issue() {
            continue;
        }

        let title = todo.title();
        let body = format!(
            "**File:** `{}:{}`\n\n**Type:** {}\n\n**Description:**\n{}\n\n---\n*Auto-generated by todo-scanner*",
            todo.file, todo.line, todo.todo_type, todo.content
        );

        let label = match todo.todo_type {
            TodoType::Fixme => "bug",
            TodoType::Todo => "enhancement",
            _ => "documentation",
        };

        let output = Command::new("gh")
            .args([
                "issue", "create", "--title", &title, "--body", &body, "--label", label,
            ])
            .output()
            .context("Failed to execute gh command. Is gh CLI installed and authenticated?")?;

        if !output.status.success() {
            eprintln!(
                "Failed to create issue for {}:{}: {}",
                todo.file,
                todo.line,
                String::from_utf8_lossy(&output.stderr)
            );
        } else {
            let issue_url = String::from_utf8_lossy(&output.stdout);
            println!("  âœ“ Created: {}", issue_url.trim());
        }
    }

    Ok(())
}

fn is_excluded(path: &Path, exclude_patterns: &[String]) -> bool {
    let path_str = path.display().to_string();
    exclude_patterns
        .iter()
        .any(|pattern| path_str.contains(&pattern.replace("**/", "").replace("/**", "")))
}

fn matches_any_pattern(path: &Path, patterns: &[String]) -> bool {
    let extension = path.extension().and_then(|e| e.to_str());

    patterns.iter().any(|pattern| {
        if let Some(ext) = pattern.strip_prefix("**/*.") {
            extension == Some(ext)
        } else {
            false
        }
    })
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;
    use tempfile::TempDir;

    #[test]
    fn test_scan_todos_finds_todo_comments() {
        let temp_dir = TempDir::new().unwrap();
        let file_path = temp_dir.path().join("test.rs");

        fs::write(
            &file_path,
            "// TODO: Fix this bug\nfn main() {}\n// FIXME: Refactor",
        )
        .unwrap();

        let todos = scan_todos(temp_dir.path(), &["**/*.rs".to_string()], &[]).unwrap();

        assert_eq!(todos.len(), 2);
        assert_eq!(todos[0].todo_type, TodoType::Todo);
        assert_eq!(todos[1].todo_type, TodoType::Fixme);
    }

    #[test]
    fn test_detects_issue_references() {
        let temp_dir = TempDir::new().unwrap();
        let file_path = temp_dir.path().join("test.rs");

        fs::write(&file_path, "// TODO (#123): Fix this\n").unwrap();

        let todos = scan_todos(temp_dir.path(), &["**/*.rs".to_string()], &[]).unwrap();

        assert_eq!(todos.len(), 1);
        assert!(todos[0].issue_reference.is_some());
        assert!(!todos[0].needs_issue());
    }

    #[test]
    fn test_todo_without_reference_needs_issue() {
        let todo = TodoItem {
            file: "test.rs".to_string(),
            line: 1,
            todo_type: TodoType::Todo,
            content: "Fix this".to_string(),
            issue_reference: None,
        };

        assert!(todo.needs_issue());
    }

    #[test]
    fn test_note_does_not_need_issue() {
        let todo = TodoItem {
            file: "test.rs".to_string(),
            line: 1,
            todo_type: TodoType::Note,
            content: "Important info".to_string(),
            issue_reference: None,
        };

        assert!(!todo.needs_issue());
    }
}
